// ==UserScript==
// @run-at	document-start
// ==/UserScript==

//use strict enables let, which makes variables work like REAL variables.
//(i.e. can be scoped more precisely than just "the function i'm in").
'use strict';
//========================================================================


//runs after the "load" event of a specific account's page, e.g. weibo.com/dealmoon
function specificAccountWeiboHandler()
{
	//first, parse the page: figure out which account's page we're on, 
	//scrape all of the posts visible, and record the oldest date among them.
	let thePageRetStuff = parseCurPageWeiboAccount();
	let postsPresent = thePageRetStuff.postsPresent;
	let curPageAccountID = thePageRetStuff.accountID;
	let curPageAccountName = thePageRetStuff.accountName;
	
	
	
	
	
	
	
	
	
	
	
	
	//DEBUG TEST TRIM
	//let tempPP = [];
	//if(confirm("DEBUG: delete posts on even minutes?"))
	//{
	//	for(let ppInd = 0; ppInd < postsPresent.length; ppInd++)
	//		if((new Date(postsPresent[ppInd].datePosted)).getUTCMinutes() % 2 > 0)
	//			tempPP.push(postsPresent[ppInd]);
	//	postsPresent = tempPP;
	//}
	//DEBUG TEST TRIM
	
	
	
	
	
	
	
	

	
	
	
	//next, initiate a retrieval from storage of all of this account's posts.
	//retrieve back to the oldest date appearing on the page.
	//NOTE "back to the oldest date appearing on the page" must not include pinned / hot / w/e posts, 
	//or else we can get false positive deletions. parseCurPageWeiboAccount() now has logic to handle that.
	let call_getAccountPostsBackTo = {};
	call_getAccountPostsBackTo.functionNameToCall = "MPIstorage_getAccountPostsBackTo";
	call_getAccountPostsBackTo.oldestDateUTCMSSE = thePageRetStuff.oldestPost;
	call_getAccountPostsBackTo.accountID = curPageAccountID;
	chrome.runtime.sendMessage(call_getAccountPostsBackTo, function(storedPosts){
	
	
	
	//console.log("storedPostsstoredPostsstoredPosts: \n"+textOfPosts(storedPosts));
	let postsPresentStripped = stripObjectsToPostFields(postsPresent);
	//console.log("postsPresent! oldest post: "+thePageRetStuff.oldestPost+", posts: \n"+textOfPosts(postsPresentStripped));
	
	let allDeterminedDeleted = setDifference(storedPosts, postsPresentStripped, comparePosts);
	let localNewDeleted = [];
	let alreadySignedDeleted = [];
	
	//anything missing from the page, remember for later that, regardless of the other 
	//attributes we're about to discuss, it's a deleted post. (with <now> for dateDeleted.)
	let batchDeletedTime = Date.now();
	for(let adInd = 0; adInd < allDeterminedDeleted.length; adInd++)
	{
		if(allDeterminedDeleted[adInd].dateDeleted == MSSE_DATE_MAX)
		{
			allDeterminedDeleted[adInd].dateDeleted = batchDeletedTime;
			if(allDeterminedDeleted[adInd].isReblog)
				allDeterminedDeleted[adInd].reblog.dateDeleted = batchDeletedTime;
		}
		
		//We must ONLY sign posts that were ACTUALLY observed by us. I.e.: if we query 
		//the server and get some deleted posts from others, they go into storage. 
		//Then, the next time we visit the page, they come out of storage, alongside posts
		//we observed+stored in there ourself. Those self-stored posts we want to sign if they
		//have been deleted, but we do NOT want to sign other people's posts! 
		//So, need to distinguish which posts in storage came from us. We will be going by
		//"posts that go to/from the server are always signed, so not signed ==> generated by ourself."
		if(allDeterminedDeleted[adInd].hasSignature)
			alreadySignedDeleted.push(allDeterminedDeleted[adInd]);
		else
			localNewDeleted.push(allDeterminedDeleted[adInd]);
	}
	
	//console.log("DEBUG: localNewDeleted: \n"+textOfPosts(localNewDeleted));
	//console.log("DEBUG: alreadySignedDeleted: \n"+textOfPosts(alreadySignedDeleted));
	
	//========signedLocallyDeterminedDeleted = signAllDeletedPosts(localNewDeleted)========
	let call_signAllDeletedPosts = {};
	call_signAllDeletedPosts.functionNameToCall = "MPIsubtleCrypto_signAllDeletedPosts";
	call_signAllDeletedPosts.allPostsToSign = localNewDeleted;
	call_signAllDeletedPosts.ownWeiboID = global_ownWeiboID;
	call_signAllDeletedPosts.ownWeiboNickname = global_ownWeiboNickname;
	chrome.runtime.sendMessage(call_signAllDeletedPosts, function(signedLocallyDeterminedDeleted){
	//========signedLocallyDeterminedDeleted = signAllDeletedPosts(localNewDeleted)========
		
	//alert("DEBUG: signedLocallyDeterminedDeleted: \n"+textOfPosts(signedLocallyDeterminedDeleted));
	let allSignedDeleted = setUnion(alreadySignedDeleted, signedLocallyDeterminedDeleted,
									comparePosts, tiebreakPosts);
	//alert("DEBUG: allSignedDeleted: \n"+textOfPosts(allSignedDeleted));
	
	//insert posts we were able to realize were deleted (without waiting for server) into the page
	insertDeletedPosts(allSignedDeleted, true);
	//(true meaning this is a specific user's account page, rather than the home page)
	
	//query the server for deleted posts: tell it the set of authors we are interested in 
	//(here, [accountID]), and the oldest deleted post we would want to see 
	//(here, thePageRetStuff.oldestPost).
	//TOODO LONGTERM make sure the forever-loading thing's activation triggers all of this to happen again, 
	//TOODO LONGTERM so we get the opportunity to see deleted posts further back than ONLY top of main feed)
	//========queryDeletedPosts([curPageAccountID], thePageRetStuff.oldestPost)========
	let call_queryDeletedPosts = {};
	call_queryDeletedPosts.functionNameToCall = "MPIcomms_queryDeletedPosts";
	call_queryDeletedPosts.authorList = [curPageAccountID];
	call_queryDeletedPosts.oldestDate = thePageRetStuff.oldestPost;
	chrome.runtime.sendMessage(call_queryDeletedPosts, function(serverReportedDeleted){
	//========queryDeletedPosts([curPageAccountID], thePageRetStuff.oldestPost)========
	
	//console.log("DEBUG: serverReportedDeleted: \n"+textOfPosts(serverReportedDeleted));
	//alert("DEBUG: serverReportedDeleted: \n"+textOfPosts(serverReportedDeleted));

	
	//insert posts into the page
	insertDeletedPosts(setDifference(serverReportedDeleted, allSignedDeleted,
						comparePosts),	true); //true: this is a specific user's account page
	
	//Report any new deleted posts to the server. This USED to be
	//(signedLocallyDeterminedDeleted - serverReportedDeleted) to save on bandwidth,
	//but now that we have the verification stuff, the server would like to hear
	//about deleted posts from everyone who notices them, so it can collect lots of
	//signatures for each deleted post.
	//========reportAllDeletedPosts(signedLocallyDeterminedDeleted)========
	let call_reportAllDeletedPosts = {};
	call_reportAllDeletedPosts.functionNameToCall = "MPIcomms_reportAllDeletedPosts";
	call_reportAllDeletedPosts.allPosts = signedLocallyDeterminedDeleted;
	chrome.runtime.sendMessage(call_reportAllDeletedPosts);
	//========reportAllDeletedPosts(signedLocallyDeterminedDeleted))========
	
	//add to storage: present-on-the-page posts (postsPresentStripped), 
	//deleted posts already in storage (allSignedDeleted), 
	//and any deleted posts the server gave us (serverReportedDeleted).							
	let postsToUpdateWith = setUnion(setUnion(postsPresentStripped, allSignedDeleted, 
												comparePosts, tiebreakPosts), 
									serverReportedDeleted, comparePosts, tiebreakPosts);
	//========updateStoredPosts(postsToUpdateWith)=============================
	updateStoredPosts(postsToUpdateWith);
	//let call_updateStoredPosts = {};
	//call_updateStoredPosts.functionNameToCall = "MPIstorage_updateStoredPosts";
	//call_updateStoredPosts.updateIntoStorage = postsToUpdateWith;
	//chrome.runtime.sendMessage(call_updateStoredPosts, function(){});
	//========updateStoredPosts(postsToUpdateWith)=============================
});});});}


//runs after the "load" event of a user's main feed page.
function mainWeiboPageHandler()
{
	//first parse the page: get all of the posts as far back as we can see (i.e. down to the dynamic
	//forever-load thing at the bottom).
	//NOTE: yes parse; we need to to get the DOM objects so we know where to insert, and if we're 
	//doing that, might as well record whatever we see; it's another opportunity and is free.
	let parseWeiboHomepageRet = parseWeiboHomepage();
	let oldestPostDate = parseWeiboHomepageRet.oldestPost;
	let postsPresent = parseWeiboHomepageRet.postsPresent;

	//next, initiate a retrieval from storage of all known-deleted posts we're aware of 
	//(which, given the current usage of storage, means retrieving all posts and checking 
	//which ones are marked deleted), going back to the oldest date appearing on the page.
	getAllStoredDeletedPostsSince(oldestPostDate, global_followedIDs, function(allStoredPosts, storedDeletedPosts){
		
	//console.log("getAllStoredDeletedPostsSince: allStoredPosts: "+JSON.stringify(allStoredPosts));
	//console.log("getAllStoredDeletedPostsSince: storedDeletedPosts: "+JSON.stringify(storedDeletedPosts));
	
	let postsPresentStripped = stripObjectsToPostFields(postsPresent);
	updateStoredPosts(setDifference(postsPresentStripped, allStoredPosts, comparePosts));
	
	//insert the locally-stored deleted posts into the page.
	insertDeletedPosts(storedDeletedPosts, false); //false: home page, not a specific account page
	
	//query the server for deleted posts: tell it the set of authors we are interested in (everyone 
	//we follow), and the oldest deleted post we would want to see (nothing older than the oldest 
	//post currently on the page). insert into the page those posts in the response that 
	//weren't already present in our storage.
	queryDeletedPosts(global_followedIDs, oldestPostDate, function(serverReportedDeleted){
		
	insertDeletedPosts(setDifference(serverReportedDeleted, storedDeletedPosts, comparePosts),
						false); //false: home page, not a specific account page
	updateStoredPosts(serverReportedDeleted);
	
	//TOODO LONGTERM make sure the forever-loading thing's activation triggers all of this to happen again,
	//..... LONGTERM so we get the opportunity to see deleted posts further back than ONLY top of main feed)
});});}


//https://github.com/rafaelw/mutation-summary
function specificPageOnChange(mutationSummaries)
{
	let cardwrapsOnly = [];
	for(let i=0; i<mutationSummaries.added.length; i++)
		if(mutationSummaries.added[i].classList.contains("WB_cardwrap"))
			cardwrapsOnly.push(mutationSummaries.added[i]);
	
	
	//TOODO LONGTERM should have some sort of tag on the posts we insert ourself so we know to ignore them
	//..... LONGTERM when we get in here
	
	//TOODO LONGTERM actually... perhaps the right approach is to have this onSummaryChange function here just
	//..... LONGTERM check whether any cardwraps (that were NOT created by us) have been inserted, and if so,
	//..... LONGTERM just trigger the whole "handle page" thing to happen again. (in which case the handle page
	//..... LONGTERM thing would also need to know that cardwraps added by us don't count as real cardwraps)
	
	//TOODO LONGTERM hmm actually... it's not JUST infinite loading, it's also multi-page, which would also 
	//..... LONGTERM take some logic, i think. in that case, it might be better to just hold off on any of
	//..... LONGTERM this more-than-front-page stuff for now. Anyways, I feel like people who have important
	//..... LONGTERM deleted posts probably aren't posting so fast that the deleted posts would very quickly
	//..... LONGTERM get pushed off their front page, so it should be not too bad......
}

//theCallback(bool wasStarted)
function checkRegistrationStarted(theCallback)
{
	chrome.storage.local.get(["ghostpostRegistrationPost", "ghostpostRegistrationSucceeded"], function(getResults){
	
	let regPostText = getResults["ghostpostRegistrationPost"];
	let regSucceeded = getResults["ghostpostRegistrationSucceeded"];
	
	if((typeof regPostText === "undefined" || regPostText === "") && (typeof regSucceeded === "undefined" || regSucceeded === false))
		theCallback(false);
	else
		theCallback(true);
});}

function afterWeiboLoad()
{
	loadOrParseOwnUIDAndFollowedUIDs(function(ourUID, ourNickname, followedUIDs){
	//someone else's wall page: $CONFIG['location']='page_100505_home'; 
	//my own wall page: $CONFIG['location']='page_100505_home'; 
	//my home page: $CONFIG['location']='v6_content_home';
	//my home page (this one is empty for all other page types i've seen): 
					//$CONFIG['pageid']='v6_content_home'; 
	//my followed page: $CONFIG['location']='page_100505_myfollow'; 
	//displaying the comments of a single post: $CONFIG['location']='page_100605_single_weibo'; 
	let locationString = extractConfigVal(document.documentElement.outerHTML, "location");
	let pageidString = extractConfigVal(document.documentElement.outerHTML, "pageid");
	
	//someone else's page: $CONFIG['oid']='2132734472'; (I.E. NOT OWN UID)
	//$CONFIG['oid']='2132734472';
	let oidString = extractConfigVal(document.documentElement.outerHTML, "oid");
	
	if(typeof oidString === "undefined")
		return;
	
	if(typeof locationString === "undefined")
		return;
	
	if(ourUID === WEIBO_NONEXISTANT_ID)
	{
		alert("GhostPost cannot currently function, because you have not logged into Weibo yet. "+
		"Once you log into Weibo, GhostPost will never show this message again.");
		return;
	}
	
	checkRegistrationStarted(function(regWasStarted){
		
	if(!regWasStarted)
	{
		alert("Please click the ghost icon in the top right of your browser (to the right "+
		"of the URL bar) to begin proving to us that you own your Weibo account! GhostPost "+
		"cannot function until you have proven it.");
		return;
	}
	
	
	global_ownWeiboID = ourUID;
	global_ownWeiboNickname = ourNickname;
	global_followedIDs = followedUIDs;
	
	let theOID = parseInt(oidString, 10);
	
	//==============================================================================
	if(					 theOID !== ourUID && 
			locationString.substring(locationString.length-4, locationString.length) 
								=== "home")
	//if it's someone's wall
	{
		//https://github.com/rafaelw/mutation-summary
		//newCardwrapMutationObserver = new MutationSummary({callback: specificPageOnChange,
		//													queries: [{element: "div"}]});
		specificAccountWeiboHandler(ourUID);
	}
		
	//------------------------------------------------------------------------------
		
	else if(			 theOID === ourUID && 
			pageidString.substring(pageidString.length-12, pageidString.length) 
								=== "content_home" &&
			locationString.substring(locationString.length-12, locationString.length) 
								=== "content_home")
	//else if it's the home page
	{
		//https://github.com/rafaelw/mutation-summary
		//newCardwrapMutationObserver = new MutationSummary({callback: mainPageOnChange,
		//													queries: [{element: "div"}]});
		mainWeiboPageHandler(ourUID, followedUIDs);
	}
	//==============================================================================
});});}


//TOODO LONGTERM ooohhh forever loading thing... appears to work via this XHR:
//http://weibo.com/p/aj/v6/mblog/mbloglist?ajwvr=6&domain=100505&from=feed&loc=nickname&pre_page=1&page=1&max_id=&end_id=3878453499490722&pagebar=0&filtered_min_id=&pl_name=Pl_Official_MyProfileFeed__23&id=1005055103578591&script_uri=/u/5103578591&feed_type=0&domain_op=100505&__rnd=1440179165846
//
//another example: (NOTE: __rnd is just seconds since epoch... wait... maybe not...)
//http://weibo.com/p/aj/v6/mblog/mbloglist?ajwvr=6&domain=100505&from=feed&loc=nickname&pre_page=1&page=1&max_id=&end_id=3878453499490722&pagebar=1&filtered_min_id=&pl_name=Pl_Official_MyProfileFeed__23&id=1005055103578591&script_uri=/u/5103578591&feed_type=0&domain_op=100505&__rnd=1440179170815


//TOODO LONGTERM when the infinite scrolling thing loads more posts, this stuff needs to look at them.
//..... LONGTERM maybe... like, set some property of the examined cardwraps, and have some 
//..... LONGTERM mutation observer thing of the page, looking for new cardwraps?
let newCardwrapMutationObserver = {};
window.addEventListener('load', function() 
{
	//TRIM DEBUG various "just do it" stuff
	
	//clear stored uid
	//let storeUIDObj = {};
	//storeUIDObj["ghostpostmyownuid"] = 0;
	//chrome.storage.local.set(storeUIDObj);
	//return;
	
	//nuke storage
	//chrome.storage.local.clear();
	
	//chrome.storage.local.remove("ghostpostRegistrationPost");
	
	try{afterWeiboLoad();}
	catch(e)
	{
		let call_tryReportError = {};
		call_tryReportError.functionNameToCall = "MPIcomms_tryReportError";
		call_tryReportError.errorString = e.stack.toString();
		chrome.runtime.sendMessage(call_tryReportError);
		//alert("DEBUG STACK TRACE: "+e.stack.toString());
	}
});

